/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 2.16.0 from webgme on Fri Nov 17 2017 17:12:36 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of CPNMarkingGenerator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin CPNMarkingGenerator.
     * @constructor
     */
    var CPNMarkingGenerator = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    CPNMarkingGenerator.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    CPNMarkingGenerator.prototype = Object.create(PluginBase.prototype);
    CPNMarkingGenerator.prototype.constructor = CPNMarkingGenerator;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    CPNMarkingGenerator.prototype.main =  function (callback) {
		var self = this,
		   activeNode = this.activeNode,
		   core = this.core,
		   logger = this.logger;
		   
		self.loadNodeMap()
			.then( function(nodeMap) {
			for(const node in nodeMap){
				if ( self.isMetaTypeOf(nodeMap[node], self.META.SoftwareBus) ){
						genSubscriberTable(self, nodeMap, nodeMap[node]);
				}
			}
			
			callback();
		})
			.catch( function(err) {
			logger.error(err);
			callback(err);
		});
	}
	
	function genSubscriberTable(self, nodeMap, busNode) {
	   var core = self.core,
			logger = self.logger,
			cfsNode = core.getParent(busNode),
			pipeNodes = [];
	  
			/* Function to find all nodes of a given meta type (metaName) contained within a node */
		  /* Only searches immediate children. Returns array of desired nodes */
		  function getContainedMetaType(node, metaType){
			let childIds = core.getChildrenRelids(node),
				nodes = [];
			
			for (let i=0; i<childIds.length; i++){
			  let child = core.getChild(node, childIds[i]);
			  
			  if ( self.isMetaTypeOf(child, metaType) ){
				nodes.push(child);
			  }
			}
			return nodes;
		  }
		  
		  /* Load node map and find all connected pipes */
		/* Find all pipes within CFS system */
		let childIds = core.getChildrenPaths(cfsNode);
		for (let i=0; i<childIds.length; i++){
		  let child = nodeMap[ childIds[i] ],
			  nodes = [];
		  nodes = getContainedMetaType(child, self.META.MSGPipe);
		  pipeNodes = pipeNodes.concat(nodes);
		}

		/* Get names of messages within pipes */
		let msgNodes = [];
		for (let i=0; i<pipeNodes.length; i++){
		  msgNodes = msgNodes.concat( getContainedMetaType(pipeNodes[i], self.META.MessageTypes) );
		}

		/* Find corresponding msg_id (default 0) for each message type */
		let msgIds = {},
			usedIds = [];
		for (let i=0; i<msgNodes.length; i++){
		  let msgName = core.getAttribute(msgNodes[i], "name"),
			  msgId = core.getAttribute(msgNodes[i], "msg_id");
		  
		  if (msgId == 0) { // Default Value. msg_id not set
			if (!msgIds[msgName]){ // If this msgName has not yet been seen
			  msgIds[msgName] = 0;
			}
		  }
		  else { // Specific msg_id has been set in model
			msgIds[msgName] = msgId;
			usedIds.push(msgId);
		  }
		}

		/* Assign unique ID's to all unassigned message types */
		let nextId = 1,
			nextIdIdx = 0;
		usedIds.sort(function(a,b){return a<b});
		for (const msgName in msgIds){
		  // If message already has an id, continue
		  if (msgIds[msgName] > 0){
			continue;
		  }
		  
		  // Check if nextId exists in sorted usedIds array. If so, increment until it does not.
		  while (nextId == usedIds[nextIdIdx]){ 
			nextId++;
			nextIdIdx++;
		  }
		  
		  msgIds[msgName] = nextId;
		  nextId++;
		}

		/* Set all message nodes msg_id to assigned ID number */
		for (let i=0; i<msgNodes.length; i++){
		  let msgName = core.getAttribute(msgNodes[i], "name"),
			  msgId = msgIds[msgName];
		  
		  debugger;
		  core.setAttribute(msgNodes[i], 'msg_id', msgId);
		}

		/* Create/replace subscriber table in software bus node */
		let subTableNode = core.createNode({parent: busNode, base: self.META.SubscriptionTable}),
			subPipeNodes = pipeNodes.filter(function(node) { return self.isMetaTypeOf(node, self.META.SUBPipe); });
		for (let i=0; i<subPipeNodes.length; i++){
		  let subMsgNodes = getContainedMetaType(subPipeNodes[i], self.META.MessageTypes),
			  appNode = core.getParent(subPipeNodes[i]),
			  appName = core.getAttribute(appNode, 'name'),
			  subscriberNode = core.createNode({parent: subTableNode, base: self.META.Subscriber});
		  
		  core.setAttribute(subscriberNode, 'name', appName);
		  for (let j=0; j<subMsgNodes.length; j++){
			let msgName = core.getAttribute(subMsgNodes[j], 'name'),
				msgId = core.getAttribute(subMsgNodes[j], 'msg_id'),
				subbedMsgNode = core.createNode({parent: subscriberNode, base: self.META.Message});
			
			core.setAttribute(subbedMsgNode, 'name', msgName);
			core.setAttribute(subbedMsgNode, 'msg_id', msgId);
		  }
		}
	
	}

    return CPNMarkingGenerator;
});
